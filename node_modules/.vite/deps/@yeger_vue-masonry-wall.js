import {
  Fragment,
  createElementBlock,
  createTextVNode,
  defineComponent,
  nextTick,
  normalizeStyle,
  onBeforeUnmount,
  onMounted,
  openBlock,
  ref,
  renderList,
  renderSlot,
  toDisplayString,
  toRefs,
  unref,
  watch
} from "./chunk-V5T7GOSI.js";
import "./chunk-FAW2VN4A.js";

// node_modules/@yeger/vue-masonry-wall-core/dist/index.mjs
function _({
  columns: v,
  columnWidth: l,
  emit: d,
  gap: g,
  items: w,
  maxColumns: o,
  minColumns: i,
  nextTick: M,
  onBeforeUnmount: k,
  onMounted: Y,
  rtl: y,
  scrollContainer: h,
  ssrColumns: s,
  vue: D2,
  wall: f,
  watch: p
}) {
  function R2(t, e, r, u) {
    const a = T(r);
    return u + e + a <= t ? R2(
      t,
      e,
      r + 1,
      u + e + a
    ) : r;
  }
  function T(t) {
    const e = Array.isArray(l.value) ? l.value : [l.value];
    return e[t % e.length];
  }
  function b() {
    const t = R2(
      f.value.getBoundingClientRect().width,
      g.value,
      0,
      // Needs to be offset my negative gap to prevent gap counts being off by one
      -g.value
    ), e = S(E2(t));
    return e > 0 ? e : 1;
  }
  function E2(t) {
    const e = o == null ? void 0 : o.value;
    return e && t > e ? e : t;
  }
  function S(t) {
    const e = i == null ? void 0 : i.value;
    return e && t < e ? e : t;
  }
  function B(t) {
    return Array.from({ length: t }).map(() => []);
  }
  if (s.value > 0) {
    const t = B(s.value);
    w.value.forEach(
      (e, r) => t[r % s.value].push(r)
    ), v.value = t;
  }
  async function A(t) {
    if (t >= w.value.length)
      return;
    await M();
    const e = [...f.value.children];
    y.value && e.reverse();
    const r = e.reduce(
      (u, a) => a.getBoundingClientRect().height < u.getBoundingClientRect().height ? a : u
    );
    v.value[+r.dataset.index].push(t), await A(t + 1);
  }
  async function c(t = false) {
    if (v.value.length === b() && !t) {
      d(D2 === 2 ? "redraw-skip" : "redrawSkip");
      return;
    }
    v.value = B(b());
    const e = h == null ? void 0 : h.value, r = e ? e.scrollTop : window.scrollY;
    await A(0), e ? e.scrollBy({ top: r - e.scrollTop }) : window.scrollTo({ top: r }), d("redraw");
  }
  const n = typeof ResizeObserver > "u" ? void 0 : new ResizeObserver(() => c());
  return Y(() => {
    c(), n == null || n.observe(f.value);
  }), k(() => n == null ? void 0 : n.unobserve(f.value)), p([w, y], () => c(true)), p([l, g, i, o], () => c()), { getColumnWidthTarget: T };
}

// node_modules/@yeger/vue-masonry-wall/dist/index.mjs
var D = ["data-index"];
var E = defineComponent({
  __name: "masonry-wall",
  props: {
    columnWidth: { default: 400 },
    items: {},
    gap: { default: 0 },
    rtl: { type: Boolean, default: false },
    ssrColumns: { default: 0 },
    scrollContainer: { default: null },
    minColumns: { default: 1 },
    maxColumns: { default: void 0 },
    keyMapper: { default: void 0 }
  },
  emits: ["redraw", "redrawSkip"],
  setup(t, { emit: s }) {
    const c = t, g = s, r = ref([]), i = ref(), { getColumnWidthTarget: k } = _({
      columns: r,
      emit: g,
      nextTick,
      onBeforeUnmount,
      onMounted,
      vue: 3,
      wall: i,
      watch,
      ...toRefs(c)
    });
    return (e, F) => (openBlock(), createElementBlock("div", {
      ref_key: "wall",
      ref: i,
      class: "masonry-wall",
      style: normalizeStyle({ display: "flex", gap: `${e.gap}px` })
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(r.value, (w, a) => (openBlock(), createElementBlock("div", {
        key: a,
        class: "masonry-column",
        "data-index": a,
        style: normalizeStyle({
          display: "flex",
          "flex-basis": `${unref(k)(a)}px`,
          "flex-direction": "column",
          "flex-grow": 1,
          gap: `${e.gap}px`,
          height: [
            "-webkit-max-content",
            "-moz-max-content",
            "max-content"
          ],
          "min-width": 0
        })
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(w, (l, m) => {
          var u;
          return openBlock(), createElementBlock("div", {
            key: ((u = e.keyMapper) == null ? void 0 : u.call(e, e.items[l], a, m, l)) ?? l,
            class: "masonry-item"
          }, [
            renderSlot(e.$slots, "default", {
              item: e.items[l],
              column: a,
              row: m,
              index: l
            }, () => [
              createTextVNode(toDisplayString(e.items[l]), 1)
            ])
          ]);
        }), 128))
      ], 12, D))), 128))
    ], 4));
  }
});
var R = (() => {
  const t = E;
  return t.install = (s) => {
    s.component("MasonryWall", t);
  }, t;
})();
export {
  R as default
};
//# sourceMappingURL=@yeger_vue-masonry-wall.js.map
